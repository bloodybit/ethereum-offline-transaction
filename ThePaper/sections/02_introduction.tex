\section{Introduction}
\label{S:1}

We are currently living in an era where applications are heavily data-centric and rely on information provided by users. It is the era of the \textit{Online Social Networks} (OSN) \cite{gondor_sonic:_2014} (e.g. Facebook, Twitter), where a person is analyzed in terms of interests and interaction with peers, building a network of connections and messages. As time passes, this information converges to create a digital identity. However, this identity is bound to a particular application with the power to influence the behavior of the person, how she interacts, and what she sees. This is a well-calculated lock-in effect used to bind users to a service \cite{gondor_distributed_2016}. 
\\

Result of the aforementioned model is that a person tends to have different identities (i.e. social profiles) with replicated information in different OSN platforms. These platforms cannot communicate with each other without additional plugins or services. SONIC \cite{gondor_sonic:_2014} proposes an approach to overcome these problems by creating a common API and protocol to enable the exchange of social information between different social networks. The user can choose whichever platform she likes while staying connected to all her friends \textbf{[http://sonic-project.net/] put as a reference}. The consequence is that the user has to share its personal information only with a single chosen platform \cite{gondor_sonic:_2014}. 

In SONIC the profile is not replicated but rather identified by a global id that is not connected to any particular application. The management of user data is unified \cite{identity_mgmt_2003}, thus giving the possibility to store information in only one place and to use common APIs to interact with other platforms. This can, in turn, increase the privacy of the user data, since other OSNs know nothing about the user except its global id.
\\

To resolve identifiers to the actual user's profile, SONIC takes advantage of a distributed system called \textit{Global Social Lookup System} (GSLS) \cite{gondor_distributed_2016}. The user's \textit{GobalID} and profile location are stored in an dataset, called SR, managed by the GSLS \cite{gondor_distributed_2016}.
\\

GSLS is currently implemented with Java and exposes APIs for creating, updating, and querying the SRs. The SRs are stored in a Distributed Hash Table \cite{tomp2p_2009} and validated using RSA private-public key encryption. However, this open-source design has some security issues. For example, one attack is to download the source code, spawn an instance of the service and add it to the network of GSLS nodes. The new malicious instance can take an outdated but signed SR and send it to the network, overriding the current entry. This old SR will be accepted because data is checked against the P2P node's signature but not against a timestamp nor a nonce. Therefore, is impossible to know if the entry is the most recent one. 
\\

To overcome this and other security issues, we propose a new design that replaces the DHT with blockchain \cite{nakamoto_bitcoin_2008}, thus taking advantage of distributed consensus, Byzantine fault tolerance, encryption, and unforgeability properties of a blockchain. The design employs Ethereum as a blockchain implementation \cite{wood_ethereum_2014}. The reason for selected Ethereum is that it provides users with sufficient storage and a Turing-complete programming language that runs on a virtual machine, called the Ethereum Virtual Machine (EVM) \cite{wood_ethereum_2014}. This enables to use the blockchain to handle logic and execute functions. In addition, can be used both as a validation (e.g. storing the hash of an entry) and storage system. 
\\

Each instance of the GSLS system exposes a RESTful API and realizes an Ethereum node that interacts with the blockchain network. For the sake of our discussion, we will use the terms Ethereum and blockchain as synonyms.
\\

The remainder of this report is structured as follows: the next section presents an overview of related works, technical framework, and background. Section 3 and 4 provide a specification of our research questions and a description of designs to solve our research problem. Section 5 provides an analysis of the design in terms of security and invasiveness from the user's perspective, as well as an evaluation of the performance of the implementation. In the last section we show the advantages and disadvantages of the proposed solution and then we conclude the report with an analysis of the system applied to different fields and propose some future work. 
