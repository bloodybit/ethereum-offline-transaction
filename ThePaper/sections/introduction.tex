\section{Introduction}
\label{S:1}

We are currently living in an era where applications are heavily data-centric and rely on information provided by users. It is the era of the \textit{Online Social Networks} (OSN) \cite{gondor_sonic:_2014} (e.g. Facebook, Twitter), where a person is analyzed in terms of interests and interaction with peers, building a network of connections and messages. As time passes, this information converges to create a digital identity. However, this identity is bound to a particular application which has the power to influence the behavior of the person, how she interacts and what she sees. This is a well-calculated lock-in effect used to bind users to a service \cite{gondor_distributed_2016}. 
\\

Result of the aforementioned model is that a person tends to segregate identities (social profiles) with replicated information in different OSN platforms. The platforms cannot communicate to each other without plugins or services. SONIC proposes an approach to overcome these problem by creating a protocol to enable communication and migration of user social profiles from one platform to another \cite{gondor_sonic:_2014}. The user profile is not replicated but identified by a global id that is not connected to any particular application. The management of user data in unified \cite{identity_mgmt_2003}, giving the possibility to access the same unique piece of information from any social network. This can, in turn, improve the privacy of the user data
%(e.g. interact with people even if not in the same OSN).
, since the OSN knows nothing about the user except its global id.
\\

To resolve identifiers to the actual user profile, SONIC takes advantage of a distributed system called \textit{Global Social Lookup System} (GSLS) \cite{gondor_distributed_2016}. User's \textit{GobalID} and profile location are stored in an dataset, called \textit{Social Record}, managed by the GSLS \cite{gondor_distributed_2016}.
\\

GSLS is currently implemented with Java and exposes APIs for creating, updating and querying the Social Records. The Social Records are stored in a Distributed Hash Table \cite{tomp2p_2009} and validated with RSA private-public key encryption. However, this open-source design has some security issues. As an example, we describe one attack: it is possible to download the source code, spawn an instance of the service and add it to the network of GSLS nodes. The malicious instance can take an outdated but signed Social Record and send it to the network, overriding the current entry. This can be achieved because data is checked against the P2P node's signature but nor against a timestamp nor a nonce. Therefore, is not possible to infer if the entry is the most recent one. 
\\

To overcome this and other security issues, we propose a new design that replace the DHT with blockchain \cite{nakamoto_bitcoin_2008}, taking advantage of distributed consensus, Byzantine fault tolerance, encryption, and unforgeability properties. The system employs Ethereum as a blockchain implementation \cite{wood_ethereum_2014}. The reason is based on the fact that Ethereum provides users with sufficient storage and a Turing-complete programming language that runs on a virtual machine, called Ethereum Virtual Machine (EVM) \cite{wood_ethereum_2014}. Therefore, it is possible to use the blockchain to handle logic and execute functions. In addition, can be used both as a validation (e.g. storing the hash of an entry) and storage system. 
\\

Each instance of the GSLS system exposes a RESTful API that holds an Ethereum node and interacts with the blockchain network. For the sake of our discussion, we will use the terms Ethereum and blockchain as synonyms.
\\

The remainder of this report is structured as follows: the next section presents an overview of related works, technical framework, and background. Section 3 and 4 provide a specification of our research questions and the description of possible designs to solve our research problem. Section 5 provides an analysis of the design in terms of security and invasiveness from the user perspective, as well as an evaluation of the performances of the implementation. In the last section we show the pro and cons of the proposed solution and then we conclude the report with a description of future work. 
